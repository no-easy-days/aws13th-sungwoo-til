# [2026-01-05 TIL]

## 📝 배운 내용 (Today I Learned)

### 서버 & 클라이언트

- 서버도 클라이언트가 될 수 있다. 서버가 다른 서버에 요청하면 클라이언트가 됨.
- 클라이언트 뿐만 아니라 서버에서도 헤더를 붙일 수 있음.
- 서버 운용은 비용합리적인 것이 최우선 목표
- 프록시: 중개 역할
- 단일 장애점(SPOF): 동작하지 않으면 전체 시스템이 동작하지 않게 하는 요소


### DNS

- 도메인: 인터넷 상의 전화번호부
- dns를 통해 사이트의 주소를 바로 얻을 수 있음
- 실제로는 서버가 여러겹에 감춰져 있음. 호스팅 업체(클라우드 플레어, 아마존 등)에서 준 IP로 1차적으로 감춰줌. 그 이후에 들여보내도 os에서 거르고 웹서버에서 거르고 was에서 거르고 ...
  실서버를 바로 알려주면 공격 위험, 따라서 우리는 실제 ip 주소를 알 수 없음
- 도메인을 컴퓨터가 해석할 떄 역방향으로 함
- 사용자 -> DNS 리졸버 -> 루트 서버 -> .com 서버 -> 최종 관리 서버
- A: IPv4 주소, CNAME: 별명 주소 부여
- 인프라는 시간을 오래 잡아먹으므로 한 번 설정할 때 잘 해야 함.

### IP
- 2진수로 된(8비트짜리 4개) 집주소
- 서버의 주소가 됐다 =  호스트의 주소가 됐다
- LAN을 묶어놓은 것이 WAN
- 네트워크 = LAN + WAN

### 포트
- 포트는 한 개 당 하나만 들어갈 수 있음
- 포트의 관리자: OS
- 포트는 가급적 예약돼 있는 포트(1024~49151)은 쓰지 말고 50000번 이상 사용하자

### HTTP 프로토콜
- 웹에서 HTTP로 대화할 때 1대1로 대응
- 특징
  - 비연결성: 한 번  연결되고 계속 연결돼 있지 않음
  - 무상태성: 이전 요청 기억 못하고 응답하는 행위만 함 -> 세션이나 쿠키로 극복
- HTTP 버전마다 속도가 달라서 속도가 중요한 회사는 버전을 커스텀하기도 함(fall-back: 버전 다운)
- curl -v 명령어 써본 내용
  - Host jsonplaceholder.typicode.com:443 was resolved: jsonplaceholder.typicode.com 주소 알아냄
  - Connected to ... port 443: 443 포트 연결
  - TLS handshake, Client hello... Server hello...: 인증서로 암호 맞춤
  - SSL certificate verify ok: 검증 완료
  - GET /users/1: users의 1번 목록 가져오기
  - User-Agent: curl/8.7.1: curl이라는 프로그램 쓰고 있다고 명시
  - HTTP/2 200: 요청 성공
  - content-type: application/json: 보낼 데이터는 JSON 형식
  - { "id": 1, "name": "Leanne Graham", ... }: real 데이터
- 빈 줄(seperator): 헤더와 바디 구분
- rfc를 준수하지 않는다고 아예 실행이 안되는 건 아님

### HTTP Request
- 생성 = 상태가 변함
- GET 요청 안에는 주소가 무조건 들어가야 함
- POST에서는 데이터를 바디에 담아야 하는 이유: 보안
- HTTP 상태코드 분류
  - 200번대: 성공
  - 400번대: 클라이언트 오류
  - 500번대: 서버 오류(서버 세팅을 잘못하면 서버가 터졌을 때 400번대를 띄우는 경우도 있음)
  - 상태코드를 200으로 때리고 ERROR로 표현해도 됨
 
### HTTP 메서드
- 행동 하나하나에 분파되는 문제 때문에 주소값에 메서드(행동)을 써놓지 않음
- 이 동작을 따로 뺴놓은 게 HTTP 메서드
- 데이터에 변화를 줄 수 있는 건 많이 없기 떄문에 95% 정도는 다 GET 요청
- 멱동성: 몇번을 수행해도 같은 결과를 냄
  - DELETE는 이미 삭제된 걸 또 삭제할 수 없으므로 멱등
  - PUT은 데이터를 아예 덮어쓰기 떄문에(전부 바뀜) 멱등
  - PATCH는 상황에 따라 다름
- HTTP 메서드는 관례일 뿐 반드시 사용해야 하는 규칙은 아님
- Graph QL
  - REST API의 대안으로 페이스북에서 만듦.
  - 클라이언트 애플리케이션이 원격 서버로부터 데이터를 요청하는 방법에 대한 사양을 정의하는 API 쿼리 언어
  - 크고 복잡하고며 서로 연결된 데이터 소스에 적합

### REST API
- REST: 상태의 표현 전달
- API: 시스템 간 통신을 위한 약속된 인터페이스
- URL: 통일된 자원의 위치
- 포트 직접 입력 가능(앞에 콜론 붙이고 포트번호)
- 프레그먼트: 그 페이지에 대한 작은 조각,  웹 페이지 내의 특정 섹션이나 리소스를 식별하는 데 사용
- REST API 설계 원칙
  1. 명사를 사용해라(동사는 HTTP 메서드에서 사용)
  2. 복수형을 사용해라(절대적이진 않지만 굳이 자원을 찢어서 관리할 이유가 없음)
  3. 계층구조를 표현해라(그렇지 않으면 파편화됨)
  4. 소문자와 하이픈을 사용해라
  5. 파일 확장자를 포함하지 마라(리소스로만 표현해라) -> content type을 통해서 지정해줘라
  근데 자바는 이 룰을 꺠는 경우도 많음
- 코드스멜: 냄새가 난다(직감적으로 잘못됨을 인지)
- fetching: 상대 서버에 요청해서 가져옴

### JSON
- 자바 스크립트에서 쓰는 객체, 데이터를 표현하는 방법의 일부
- 가독성 떄문에 XML보다 거의 JSON 사용, 컴퓨터 입장에서도 읽기 쉬움
- JSON에서는 null, python에서는 None
- 키는 무조건 큰따옴표
- value 안에 중괄호로 객체를 넣을 수 있고 배열을 넣을 수 있는 등 다양한 형태 넣기 가능
- 크게 감싸는 중괄호 대신 대괄호로 배열을 나타낼 수도 있음
- 마지막 객체 뒤에 콤마 붙이면 에러 남
- 주석 없음
- 파싱: 큰 자료에서 원하는 데이터를 원하는 때에 뽑아 쓰는 것

### 직렬화 / 역직렬화
- 직렬화: 저장하거나 전송할 수 있는 형태로 만드는 것
- 역직렬화: 직렬화한 것을 다시 응용 프로그램에서 쓸 수 있게 실제 객체로 변환
- pydentic: 유효성 검증
  - 타입 유효성 검사
  - 자동 형 변환: 타입 불일치 시 자동 형 변환
  - 필드의 기본값 지원 -> 사용자가 데이터 제공을 안해도 유효한 모델 생성 가능
  - 복잡한 데이터 구조 지원

### SQL Injection
- cursor.execute()
  - 데이터베이스 커넥션 객체로 생성된 커서를 이용해 SQL 쿼리를 실행하는 메서드
  - placeholder를 사용해 실제 값은 두번째 인자 튜플 형태로 전달하여 sql 삽입 공격 방어
 

  
## 🔥 & 해결 (Challenge & Solution)

> 오늘 겪은 문제나 도전적인 과제, 그리고 그것을 어떻게 해결했는지 기록합니다.
- **과제/문제**:

- **시도 및 해결**

회고 (Retrospective)

- **Keep (좋았던 점)**:
- **Problem (아쉬웠던 점)**:
- **Try (시도할 점)**:
모르는 건 많은데 질문하지 않는 것에 대해 고민해보았다. 질문 많은 사람들이랑 비교했을 때 뭐가 문제인지 생각해봤을 때 지식을 생각하며 내걸로 받아들이지 않고 그냥 있는대로 받아들인 게 요인인 것 같다. 내일부터는 생각이라는 것을 의식해서 해야겠다.
