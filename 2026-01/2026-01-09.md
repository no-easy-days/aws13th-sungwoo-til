# [2026-01-09 TIL]

## 📝 배운 내용 (Today I Learned)

## 제어의 역전(IoC, Inversion of Control)

- 제어의 역전은 소프트웨어 개발에서 코드의 흐름과 객체 관리를 외부로 넘김으로써, 프로그램의 유연성과 확장성을 높이는 설계 패턴
- 대부분의 소프트웨어는 개발자가 코드의 흐름(객체 생성, 메서드 호출, 데이터 흐름제어)을 직접 제어
- ***시스템이 커지면 객체 간의 의존성이 복잡해지고, 코드의 결합도가 높아지기 때문에 유지보수와 확장이 어려움***
    
    ⇒ 제어의 역전
    
- 장점
    - 유연성 - 각 객체가 외부 흐름에 의존하지 않으므로 쉽게 변경이나 확장 가능
    - 유지보수성 - 새로운 기능이 필요할 때 필요한 요소만 추가하면 됨
    - 결합도 하락 ⇒ 테스트 용이성 대폭 증가
    - 객체 간의 의존성을 프레임워크가 관리하기 때문에 각 객체가 독립적으로 테스트 가능.
- *의존성 주입*은 제어의 역전의 구체적인 구현 방법 중 하나

## 의존성 주입(dependency injection, DI)

소프트웨어 엔지니어링에서 의존성 주입은 하나의 객체가 다른 객체의 의존성을 제공하는 테크닉이다.

-위키백과 일부 발췌-

- 의존성: 한 객체가 다른 객체를 사용할 때
- 결합도: 두 모듈 간의 상호 의존 정도



    
- 정의: 두 객체 간의 관계(의존성)을 맺어주는 것
- 인터페이스를 사이에 둬서 클래스 레벨에서는 의존관계가 고정되지 않도록 하고 런타임 시에 동적으로 주입
    
    ⇒ 유연성 확보 및 결합도 하락
    
- 생성자 주입, 필드 주입, 수정자 주입 등 다양한 주입 방법이 있고 Spring 4부터는 생성자 주입을 강력히 권장
- 핵심은 객체들 간의 상호작용 최소화
    
    ⇒ 내가 무엇이 필요하면 직접 만드는 것이 아니라 전달받도록 요청
    
- 제일 쉬운 예는 블록! 각각의 모듈을 블록이라고 생각하면 어느 모듈에 이상이 생기면 그 부분만 빼고 다른 걸로 갈아낀다고 생각하기

예시)

<img width="1000" height="802" alt="image" src="https://github.com/user-attachments/assets/e2a4ae58-fb0c-418c-8701-70238c3b5730" />


- 클래스가 다른 클래스에 많이 의존하고 있는 구조를 **강한결합(tightlycoupling)**
- Car 클래스가 특정 Engine 클래스에 강한 결합으로 이루어져 있음
- 아래의 예제 코드로 보면 Car 클래스 내부에서 엔진 방식을 바꾸면 Car 클래스 내부를 재작성 필요

<img width="1072" height="632" alt="image" src="https://github.com/user-attachments/assets/ec46f7f9-fb28-4b29-8f0e-86bfe0144d3a" />


전기엔진으로 바꾸려면 car 클래스 자체를 바꿔야 함

의존성 주입을 했을 때 예시)

<img width="914" height="878" alt="image" src="https://github.com/user-attachments/assets/313acc50-4bee-44b2-82b0-b9336bc2d537" />


- 마력이 300짜리인 엔진을 미리 만들어 놓음
- Car 클래스에 엔진만 그대로 넣음
- `class Car:
  def **init**(self):
  self.engine = Engine(horsepower=300)`
    
    만약 Car 클래스를 위와 같이 썼다면 클래스를 선언했을 때 Car 코드를 뜯어 고쳐야 함
    

- 장점
    - 유지보수성
        
        객체 간의 관계 느슨 ⇒ 코드의 변경이 필요한 곳에서만 수정하면 됨
        
    - 유연성
        
        외부에 주입되는 객체를 변경함으로써 클래스의 기능을 쉽게 변경 가능
        
    - 테스트 용이성
        
        의존성 주입을 통해 가짜(Mock) 객체를 쉽게 주입 가능 ⇒ 실제 실행되지 않는 외부 시스템(DB, 외부 API 등)에 이존하지 않고도 클래스 기능 테스트 가능
        

## 객체지향 설계 5원칙(SOLID)과의 관계

### S(Sigle Responsibility Principle)

‘클래스(객체)는 단 하나의 책임만 가져야 한다.’

 ⇒ 하나의 클래스가 기능(책임)이 여러 개 있다면 기능 변경(수정)이 일어났을 때 수정해야 할 코드가 많아진다.

### **O(Open Closed Principle)**

'확장에 열려있어야 하며, 수정에는 닫혀있어야 한다'

⇒ 새로운 변경사항이 발생했을 때 유연하게 코드를 추가함으로써 큰 힘을 들이지 않고 애플리케이션 기능을 확장      하고 새로운 변경사항이 발생했을 때 객체를 직접적으로 수정하는 것을 권장

(L(Liskov Substitution Principle) - 서브타입은 언제나 부모 타입으로 교체 가능)

(I(Interface Segreation Principle) - 인터페이스를  각각 사용에 맞게끔 잘 분리)

### D(Dependency Inversion Principle)

‘어떤 클래스를 참조해야 하는 상황이라면 그 클래스를 직접 참조하는 게 아니라 그 대상의 상위 요소로 참조’

⇒ 구현 클래스에 의존하지 않고 인터페이스에 의존하라는 뜻

    = 의존관계를 맺을 떄 변화하기 어려운 것과 거의 변화가 없는 것에 의존하라는 것.

의존 역전 원칙의 지향점은 각 클래스 간의 결합도를 낮추는 것이다.

## 의존성 주입의 단점

- 책임이 분리되어 있기 때문에 클래스 수를 늘림으로써 복잡성이 증가
- 주입된 객체들에 관한 코드 추적이 어려움
- 초기 개발 노력이 필요
- 의존성 주입 프레임워크를 사용하면 빌드 시간이 늘어날 수 있으며, 프레임워크에 대한 의존도 증가

단점도 명확히 있기 때문에 꼭 써야 하는 건 아니다.

로직이 간단한 코드는 굳이 쓰지 않아도 되고 초보 개발자는 숙달시키고 익히는 데에 시간이 걸리기 때문에 차라리 의존성 주입을 쓰지 않는 게 나을 때도 있다.

## Fast API와의 관계

- **레이어드 아키텍처(Layered Architecture): 코드의 유지보수성, 확장성 및 테스트 용이성을 높이는 중요한 구조**
- 레이어드 아키텍처에서 의존성 주입 사용
    
    ⇒ 각 계층 간의 의존성을 외부에서 관리할 수 있기 떄문에 계층 간 결합도를 낮추고 각 계층을 독립적으로 테      스트하고 유지보수 가능
    
    ![image.png](attachment:213c57b4-2101-46f6-979d-eba6748695ee:image.png)
    
1. **Presentation Layer-** 클라이언트 요청을 받아 **Depends(BookService)**를 통해 Service Layer에 요청을 전달
2. **Service Layer -** 비즈니스 로직을 처리하며, **Depends(BookRepository)**를 사용하여 Repository Layer에 데이터 요청
3. **Repository Layer -** 실제 데이터베이스와 연결하여 데이터를 저장 및 조회하며, 주입받은 **DB 세션(Session)**을 활용

---

서버의 입장에서 정보를 받을 때 데이터의 상태를 오염됐다고 하고 이걸 정화하는 게 중요
스키마: 시스템 경계선 넘어와야 신뢰를 할 수 있다는 명세서
pydentic: 비즈니스 로직까지 들어갈 일을 없애주기 위해 오염된 데이터 정제


상태 유지: 이 사람을 안다는 전제 하에 대화한다
로그인 상태를 어떻게 유지?
⇒ 클라이언트의 아이디, 로그인 권한 등을 세션에 저장
서버에 인증정보를 너무 많이 관리해야 하니까 클라이언트에서 관리하게 함
헤이로드로 신뢰할 수 있는 유저에서 왔는지, 위변조됐는지 확인
만료될 떄까지 로그아웃이 안됨.엑세스 토큰으로 5분에서 10분 유지리프레쉬 토큰으로 만료 시 새로 발급해달라 요청.

객체 관계 매핑(ORM)
관계형 데이터베이스를 제대로 표현할수록 객체지향에선 더 문제가 심화됨. 객체 간의 관계를 바탕으로 코딩으로 간접적으로 sql문을 쓸 수 있음.
장점은 개발자친화적이고 객체 기반으로 사용하기 떄문에 설계와 유지보수가 좋다.
특정 데이터베이스에 종속되지 않기 때문에 여러 라이브러리 사용 가능
구조가 복잡해서 초기 설정을 잘못하면 오히려 독이 됨..
대규모 데이터에 안좋음.
sql을 안 써도 돼서 바로 할 수 있어서 편하다.

## 🔥 도전 과제 & 해결 (Challenge & Solution)

> 오늘 겪은 문제나 도전적인 과제, 그리고 그것을 어떻게 해결했는지 기록합니다.
> 
- **과제/문제**:
  도서관 프로그램을 PR을 하고 피드백 받은 것 중 도서관 회원을 등록 후 동명이인이 있으면 정보가 덮어씌워진다라는 것이 있었다.
- **시도 및 해결**:
  처음에는 동명이인을 없애기 위해서 전화번호가 다르면 다른 사람으로 인식하고 새로운 회원을 추가하는 코드를 짜려고 했다.
  코드를 작성한지 30분 정도 지나니 생각해보니까 전화번호도 각 사람의 고유번호가 아닌가?라는 발상을 했고 회원 명단 딕셔너리에 전화번호를 키값으로 받으면 되겠다고 생각했다.
  그래서 그대로 코드를 고치니 잘 작동했고 문제점도 해결되었다.
  누군가한테는 당연하다고 생각할 수 있지만 내가 느끼기엔 나 천잰가?라는 생각이 들고 이 맛에 개발하는구나라는 것을 느꼈다. 끗.

## 💭 오늘의 회고 (Retrospective)

- **Keep (좋았던 점)**: 잠도 충분히 자고 수업 종소리 메커니즘도 바뀌어서 그런지 몰입하는 시간이 이번주 평균보다 2배는 된 것 같다. 다음주에는 더 많은 몰입시간을 기대해봄직하다. 그리고 오늘 동기가 면접 보러와서 같이 점심 먹었는데 짧은 시간이었지만 매일 보던 얼굴을 오랜만에 보니 반가웠다.
- **Problem (아쉬웠던 점)**: 목표성이 아직 옅은 것 같다.
- **Try (시도할 점)**: 아쉬웠던 점에 의해 더 정량적인 목표를 세워봐야겠다고 다짐했다.

## 🔗 참고 자료 (References)

- [링크 제목](https://www.google.com/search?q=URL)
