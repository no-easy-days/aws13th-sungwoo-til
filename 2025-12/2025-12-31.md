# [2025-12-31 TIL]

## 📝 배운 내용 (Today I Learned)

### with
- 자동으로 파일을 닫아주므로 권장(close 하지 않으면 파일이 손상되거나 저장되지 않을 수 있음
- 예외가 발생해도 안전하게 저장
- try-finally 사용이 없어 코드 간결화
```python
with open('file.txt', 'r', encoding='utf-8') as f:
    content = f.read()
# with 블록을 벗어나면 자동으로 close()
```

파일이 큰 경우 반복문 사용 => 파일을 한 줄씩 읽어오기 때문에 메모리 절약
```python
with open('example.txt', 'r', encoding='utf-8') as f:
    for line in f:  # 파일 객체는 반복 가능!
        print(line.strip())
```

### 쓰기 모드
- w: 파일 삭제 후 쓰기
- a: 맨 뒤에 추가하기
- x: 파일이 이미 있으면 에러(기존 데이터를 지키기 위함)

### 바이너리 파일
- 문자열이 아닌 바이트로 다룸
- 인코딩 불필요
- r, w, a에서 r만 붙여 사용
- jpg, mp4 등에 사용

makedirs: mkdir과 달리 원하는 만큼 디렉토리 생성 가능(mkdir도 여러 파일 생성은 가능)

### 일급 객체

- 다른 객체들에게 일반적으로 적용가는한 연산을 모두 지원하는 객체
- 조건
    - 모든 일급 객체는 자료구조(변수나 데이터)에 담을 수 있어야 한다.
    - 모든 일급 객체는 함수의 파라미터로 전달할 수 있어야 한다.
    - 모든 일급 객체는 함수의 리턴값으로 사용할 수 있어야 한다.
- 파이썬의 함수도 일급 객체의 조건 만족!

### 스코프
- 영향을 미치는 범위
- inner 입장에서 inner 함수 블록 영역 안은 local scope, outer 안에 있되 inner 밖의 영역은 nonlocal scope(y 변수는 nonlocal), outer 함수 바깥 영역은 global

### 클로저
- 정의: 내부함수가 외부함수의 변수에 접근할 수 있도록 기억
- 자신을 둘러싼 함수 스코프의 상태값을 참조하는데 이 값은 함수가 메모리에서 사라져도 값이 유지, 클로저가 생성될 때 __closure__ 변수가 같이 생성되고 유지되기 때문에 기존 함수가 삭제돼도 문제없이 클로저 실행 가능
- 클로저에서 자신 안에 정의된 내부 변수가 아닌 enclosing(감싸는)하고 있는 변수에 접근하는 것을 파이썬에서 지원
- 조건
    - 해당 함수는 어떤 함수 내의 중첩된 함수여야 한다
    - 해당 함수는 자신을 둘러싼 함수 내의 상태값을 반드시 참조해야 한다
    - 해당 함수를 둘러싼 함수는 이 함수를 반환해야 한다
- 장점:
    - 관리와 책임을 명확히 할 수 있고(오직 내부함수만 접근 가능하므로 보안 강화)
    - 각 변수가 섞여 불필요한 충돌 방지할 수 있고
    - 사용환경에 맞게 임의대로 내부구조를 조정할 수 있다
 
### 데코레이터

- 기본적으로 함수를 인자로 받아 기능을 추가해 새로운 함수를 반한 = 고차함수
- 중복코드를 줄이고 유지보수 향상

### 리스트와 집합의 속도 차이와 해시 테이블

- 해시값이 달라도 메모리가 같은 곳에 저장되면 어느 하나는 다른 곳으로 넘어감
- 그리고 그 값을 찾을 땐 넘어가기 주소에서 비교하여 다르면 넘어감
- 집합은 해시를 쓰기 떄문에 시간 복잡도가 낮다

### 제너레이터와 이터레이터: 지연평가

- 이터러블: 반복문을 활용할 수 있는 대상
- 이터레이터 한계: 사용하려면 제약조건이 많아 데이터가 많고 복잡하면 다루기 어렵다. 어디까지 꺼내는지라는 게 없음. 
- 제너레이터: 이터레이터를 쉽게 만들기 위한 도구.
- 이터레이터는 데이터를 한 번에 다 박아놓고 이미 메모리에 박히면 조회를 할 때 빠르지만 메모리를 많이 차지한다.
- 제너레이터는 필요할 떄마다 실행해서 뽑아 씀.
- 일드(yeild)는 리턴이랑 같지만 그 시점에 실행을 끊고 연결하는 역할(제너레이터 도구).
